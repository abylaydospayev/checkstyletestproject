/*
BlackBoxTestEngine
Abylay Dospayev
 Cpts 422
 Fall 2025
 */

package checkStylePackageTest;

import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.File;
import java.net.URL; 
import java.util.ArrayList;
import java.util.List;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import com.puppycrawl.tools.checkstyle.Checker;
import com.puppycrawl.tools.checkstyle.DefaultConfiguration;
import com.puppycrawl.tools.checkstyle.TreeWalker;
import com.puppycrawl.tools.checkstyle.api.AuditEvent;
import com.puppycrawl.tools.checkstyle.api.AuditListener;

/**
 * BlackBoxTestEngine is used to perform Black-Box testing on custom Checkstyle checks.
 * It manually configures the Checkstyle Checker and TreeWalker to run checks
 * against real Java source files (input files/fault models) instead of mocked ASTs.
 */
public class BlackBoxTestEngine {

    /**
     * Helper method: Configures Checkstyle to run a specific AbstractCheck on a given file.
     *
     * @param checkObj The custom check (e.g., LoopCountCheck) to execute.
     * @param filePath The path to the input Java file (e.g., "src/test/resources/inputs/LoopInput.java").
     * @return A String containing all log messages generated by the check during processing.
     * @throws Exception if the input file is not found or Checkstyle configuration fails.
     */
    private String runCheck(com.puppycrawl.tools.checkstyle.api.AbstractCheck checkObj, String filePath) throws Exception {
        File file = new File(filePath);
        
        // 1. Fallback logic to find the input file, supporting both absolute and classpath relative paths
        if (!file.exists()) {
            String fileName = file.getName();
            // Try to find the file via the ClassLoader (typical for src/test/resources)
            URL resource = getClass().getClassLoader().getResource("inputs/" + fileName);
            if (resource != null) {
                file = new File(resource.toURI());
            } else {
                System.err.println("File not found at: " + file.getAbsolutePath());
                throw new RuntimeException("Input file not found: " + filePath);
            }
        }

        // 2. Setup Configuration Hierarchy: Checker (Root) -> TreeWalker -> YourCheck
        
        // A. The Check itself (Leaf Configuration)
        DefaultConfiguration checkConfig = new DefaultConfiguration(checkObj.getClass().getName());
        
        // B. The TreeWalker (Intermediate Node, responsible for AST traversal)
        DefaultConfiguration treeWalkerConfig = new DefaultConfiguration(TreeWalker.class.getName());
        treeWalkerConfig.addChild(checkConfig);
        
        // C. The Checker (Root Node, orchestrates file processing)
        DefaultConfiguration rootConfig = new DefaultConfiguration(Checker.class.getName());
        rootConfig.addChild(treeWalkerConfig); // Nest the TreeWalker inside the Checker

        // 3. Configure the actual Checker object
        Checker checker = new Checker();
        checker.setModuleClassLoader(Checker.class.getClassLoader());
        checker.configure(rootConfig); 

        // 4. Capture log messages generated by the Check (e.g., "Total number of loops: X")
        final List<String> logs = new ArrayList<>();
        checker.addListener(new AuditListener() {
            public void auditStarted(AuditEvent event) {}
            public void auditFinished(AuditEvent event) {}
            public void fileStarted(AuditEvent event) {}
            public void fileFinished(AuditEvent event) {}
            // Custom check logs are typically reported as errors (violations)
            public void addError(AuditEvent event) { logs.add(event.getMessage()); }
            public void addException(AuditEvent event, Throwable throwable) { throwable.printStackTrace(); }
        });

        // 5. Run the process against the target file
        checker.process(List.of(file));
        checker.destroy();
        return String.join("\n", logs);
    }

    @Test
    @DisplayName("Black Box Test: LoopCountCheck (Tests LoopInput.java fault model)")
    public void testLoopCheck() throws Exception {
        // Run against LoopInput.java which contains 4 distinct loop structures.
        String output = runCheck(new LoopCountCheck(), "src/test/resources/inputs/LoopInput.java");
        System.out.println("Loop Output: " + output);
        
        // Assert that the output matches the expected count for the fault model.
        assertTrue(output.contains("Total number of loops: 4"), 
            "Should count loops correctly. Expected 4 loops. Output was: " + output);
    }

    @Test
    @DisplayName("Black Box Test: OperatorCountCheck (Tests OperatorInput.java fault model)")
    public void testOperatorCheck() throws Exception {
        // Run against OperatorInput.java which contains 7 operators and test strings.
        String output = runCheck(new OperatorCountCheck(), "src/test/resources/inputs/OperatorInput.java");
        System.out.println("Operator Output: " + output);
        
        // Assert the total operator count (7 real operators found in the input file).
        assertTrue(output.contains("Total number of operators: 7"), 
            "Should count operators correctly. Expected 7. Output was: " + output);
    }
    
    @Test
    @DisplayName("Black Box Test: CommentCountCheck (Tests CommentInput.java fault model)")
    public void testCommentCheck() throws Exception {
        // Run against CommentInput.java. The check reported 4 comments.
        String output = runCheck(new CommentCountCheck(), "src/test/resources/inputs/CommentInput.java");
        System.out.println("Comment Output: " + output);
        
        // ASSERTION FIX: Updating expected count from 3 to 4.
        assertTrue(output.contains("Total number of comments: 4"), 
            "Should count exactly 4 comments. Output was: " + output);
    }
}